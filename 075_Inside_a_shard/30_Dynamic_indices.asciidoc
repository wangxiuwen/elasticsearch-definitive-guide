[[dynamic-indices]]
=== 动态更新索引

下一个需要被解决的问题((("indices", "dynamically updatable")))是怎样在保留不变性的前提下实现倒排索引的更新？
答案是: 用更多的索引。

增加新的补充索引来反映更多最近的改变，而不是直接重写整个倒排索引。每一个倒排索引都会被轮流查询到--从最老的开始--查询完后再对结果进行合并。

Elasticsearch 基于Lucene, 这个java 库引入了 _每个段搜索_ 的概念。
((("per-segment search")))((("segments")))((("indices", "in Lucene"))) 一个 _段_ 本身的含义是指一个倒排索引，
但 _索引_ 在 Lucene 中除表示所有 段_ 的 _集合外， 还增加了 _提交点_ 的概念 &#x2014; 一个文件((("commit point")))
列出了所有已知的段，就像在 <<img-index-segments>> 中描绘的那样。
新的文档像在<<img-memory-buffer>>中提到的一样，首先被添加到内存索引缓存中， 然后像 <<img-post-commit>> 提到的一样，被写入在磁盘的段中。


[[img-index-segments]]
.一个 Lucene 索引包含一个提交点和三个段
image::images/elas_1101.png["A Lucene index with a commit point and three segments"]

.索引与分片
***************************************

被混淆的概念是，一个 _Lucene 索引_ 我们在Elasticsearch称作 _分片_ 。
一个 Elasticsearch _索引_ ((("indices", "in Elasticsearch")))((("shards", "indices versus"))) 是分片的集合。
当 Elasticsearch 在索引中搜索的时候， 他发送查询到每一个属于索引的分片(Lucene 索引)，然后像<<distributed-search>>
提到的那样，合并每个分片的结果到一个全局的结果集。

***************************************

逐段搜索会以如下流程进行工作

1. 新文档被收集到内存索引缓存， 见<<img-memory-buffer>>。
2. 有时, 缓存被 _提交_:

** 一个新的段--补充倒排索引--被写入磁盘。
** 一个新的包含新段名字的 _提交点_ 被写入磁盘。
** 一个磁盘是 _fsync'ed_&#x2014; 所有写入等待文件系统缓存被刷入磁盘，来保证它们被物理写入。
3. 一个新的段开启，让它包含的文档可见以被搜索。
4. 内存缓存被清空，等待接收新的文档。

[[img-memory-buffer]]
.一个 Lucene 有内存缓存新文档的索引，准备提交:
image::images/elas_1102.png["A Lucene index with new documents in the in-memory buffer, ready to commit"]

[[img-post-commit]]
.在一次提交后，一个新的段被添加到提交点而且缓存被清空。
image::images/elas_1103.png["After a commit, a new segment is added to the index and the buffer is cleared"]

当一个查询被触发，所有的已知的段按顺序被查询。词项统计会对所有段的结果进行聚合，以保证每个词和每个文档的关联都被准确计算。
这种方式可以用相对较低的成本将新文档添加到索引。

[[deletes-and-updates]]
==== 删除和更新

段是不可改变的，所以既不能从把文档从旧的段中移除，也不能修改老的段来进行反映文档的更新。
取而代之，每一个((("deleted documents"))提交点会包含一个.del文件，文件中会列出被删除的文档和文档对应的段信息。

当一个文档被 ``删除,'' 它实际上只是在`.del`文件中被 _标记_ 删除。一个被标记删除的文档仍然可以被查询匹配到，
但是它会在最终结果被返回前从结果集中移除。

文档更新也是类似的操作方式：当一个文档被更新时，老版本文档被标记删除，文档的新版本被索引到一个新的段中。
可能两个版本的文档都会被一个查询匹配到，但是被删除的那个旧版在结果集返回前就已经被移除。

在 <<merge-process>>, 我们展示了一个被删除的文档是怎样被文件系统移除的。
