[[dynamic-indices]]
=== 动态更新索引

下一个需要被解决的问题((("indices", "dynamically updatable")))是怎样使倒排索引可以不失去不可改变的特性下可更新？
答案是: 用更多的索引。

重写整个倒排索引，增加新的补充索引来反映更多最近的改变。每个倒排索引可以反过来被查询--以最旧的开始--合并结果。

Elasticsearch 基于Lucene, 这个java 库引入了 _每个段搜索_ 的概念。
((("per-segment search")))((("segments")))((("indices", "in Lucene"))) 一个 _段_ 在它自身范围内是一个倒排索引,
但是现在这个 _索引_ 在 Lucene 中成为了一个 所有 段_ 的 _集合， 它增加了一个 _提交点_ &#x2014; 一个文件((("commit point")))
列出了所有已知的段，就像在 <<img-index-segments>> 中描绘的那样。
新的文档像在<<img-memory-buffer>>中提到的一样，首先被添加到内存索引缓存中， 然后像 <<img-post-commit>> 提到的一样，被写入在磁盘的段中。


[[img-index-segments]]
.一个 Lucene 索引包含一个提交点和三个段
image::images/elas_1101.png["A Lucene index with a commit point and three segments"]

.索引与分片
***************************************

被混淆的概念是，一个 _Lucene 索引_ 我们在Elasticsearch称作 _分片_ 。
一个 Elasticsearch _索引_ ((("indices", "in Elasticsearch")))((("shards", "indices versus"))) 是分片的集合。
当 Elasticsearch 在索引中搜索的时候， 他发送查询到每一个属于索引的分片(Lucene 索引)，然后像<<distributed-search>>
提到的那样，合并没个分片的结果到一个全局的结果集。

***************************************

每单个段搜索像下面提到的工作：

1. 新文档被收集到内存索引缓存， 见<<img-memory-buffer>>。
2. 经常性的, 缓存被 _提交_:

** 一个新的段--补充倒排索引--被写入磁盘。
** 一个新的包含新段名字的 _提交点_ 被写入磁盘。
** 一个磁盘是 _fsync'ed_&#x2014; 所有写入等待文件系统缓存被刷入磁盘，来保证它们被物理写入。
3. 一个新的段开启，让它包含的文档可见以被搜索。
4. 内存缓存被清空，等待接收新的文档。

[[img-memory-buffer]]
.一个 Lucene 有内存缓存新文档的索引，准备提交:
image::images/elas_1102.png["A Lucene index with new documents in the in-memory buffer, ready to commit"]

[[img-post-commit]]
.在一次提交后，一个新的段被添加到提交点而且缓存被清空。
image::images/elas_1103.png["After a commit, a new segment is added to the index and the buffer is cleared"]

当一个查询被发布，所有的已知的段反过来被查询。词统计汇通过所有段去聚合，以保证每个词和每个文档的关联都被准确计算。
以这种方式，新的文档可以低成本的被添加到相关索引。

[[deletes-and-updates]]
==== 删除和更新

段是不可改变的，所以文档不能从旧的段中被移除，老的段也不可以被更新来影响一个更新版本的文档。
然而，每一个 ((("deleted documents")) 提交点包含一个列出了哪个段中的哪个文档被删除了的`.del` 文件。

当一个文档被 ``删除,'' 它实际上只是在`.del`文件中被 _标记_ 删除。一个被标记删除的文档仍然可以查询匹配，
但是它会在最终结果被返回前从结果集中移除。

文档以相同的方式更新: 当一个文档被更新，文档的老版本被标记删除，文档的新版本被索引在一个新的段中。
可能文档的两个版本都会被一个查询匹配，但是旧的被删除的版本在结果集返回前已经被移除。

在 <<merge-process>>, 我们展示了一个被删除的文档是怎样被文件系统移除的。





