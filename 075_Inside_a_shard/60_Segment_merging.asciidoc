[[merge-process]]
=== 段合并

由于自动刷新流程每秒会创建一个新的段 ((("segments", "merging"))) ，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦。
每一个段都会消耗文件句柄，内存， 和cpu 运行周期。更重要的是，每一次请求都需要检查每一个段的返回结果; 段越多，搜索也就越慢。

Elasticsearch 通过在后台进程合并段来解决这个问题。((("merging segments"))) 小的段被合并到大的段，然后这些大的段再按顺序被合并到更大的段。

这也是被删除的旧文档从文件系统中被清除的时刻。((("deleted documents", "purging of"))) 被删除的文档(或被更新文档的旧版本)不会被拷贝到新的大段中。

启动段合并不需要你做任何事。进行索引和搜索时会自动进行。这个流程像在 <<img-merge>> 中提到的一样工作:

1. 当索引的时候，刷新进程创建了一个新的段，而且为搜索打开它们。

2. 合并进程选择一小部分相似大小的段，并且在后台进程将它们合并到更大的段中。这并不会中断索引和搜索。

+
[[img-merge]]
.两个提交了的段和一个未提交的段正在被合并到一个更大的段。
image::images/elas_1110.png["Two commited segments and one uncommited segment in the process of being merged into a bigger segment"]

3. <<img-post-merge>> 说明合并活动完成:
+
--
    ** 段被刷新到了磁盘。
    ** 一个新的提交点包含新的段并且不包含旧的段和更小的段被写入。
    ** 新的段被打开用来搜索。
    ** 老的段被删除。

[[img-post-merge]]
.一旦合并结束，老的段被删除
image::images/elas_1111.png["Once merging has finished, the old segments are deleted"]
--

合并大的段需要大量的I/O 和 CPU, 如果任其发展会影响搜索性能。Elasticsearch在默认情况下会对合并流程进行资源限制，所以搜索仍然
有足够的资源很好地执行。

TIP: 查看 <<segments-and-merging>> 来获取关于合并调整用例的建议。

[[optimize-api]]
==== optimize API

`optimize` API  _强制合并_ API的最好描述  ((("merging segments", "optimize API and")))((("optimize API")))((("segments", "merging", "optimize API")))。它会将一个分片强制合并到 `max_num_segments` 参数指定大小的段数目。
它的意图是减少段的数量(通常是一个)，来提升搜索性能。

WARNING: `optimize` API _不能_ 被用在一个动态索引--一个索引正在被活跃更新。后台合并流程已经可以很好地完成工作。
optimizing 会阻碍这个进程。勿扰！

在这种情况下，使用 `optimize` API 颇有益处。例如在日志这种用例下，每天、每周、每月的日志被存储在一个索引中。
老的索引实质上是只读的; 它们也并不太可能会变化。


In this case, it can be useful to optimize the shards of an old index down to
a single segment each; it will use fewer resources and searches will be
quicker:
在这种情况下，使用 optimize 优化老的索引，将每一个分片合并为一个单独的段就很有用了；这样既可以节省资源，也可以使搜索更加快速。

[source,json]
---------------------------
POST /logstash-2014-10/_optimize?max_num_segments=1 <1>
---------------------------
<1>  合并每个索引中的每个分片到一个单独的段

[WARNING]
====
请注意，使用 `optimize` API 触发段合并的话没有任何资源上的限制。可能会消耗掉你节点上全部的I/O资源, 使其没有余裕来处理搜索请求。从而使集群失去响应。
如果你想要对索引执行 `optimize`，你需要使用分片分配(查看 <<migrate-indices>>) 移动索引到一个安全的节点，再执行。
====
