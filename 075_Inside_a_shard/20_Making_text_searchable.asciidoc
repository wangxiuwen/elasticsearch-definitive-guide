[[making-text-searchable]]
=== 使一个文本可被搜索

第一个需要被解决的挑战是怎么样((("text", "making it searchable")))让一个文本可以被搜索。

传统的数据库使用一个字段存储单个值，但是这对全文检索并不够。每个文本中的单词需要被搜索，这意味着数据库需要有能力
在这一个单值字段中索引大量的值--单词。

很好的支持 _一个字段多个值_ 需求的数据结构((("inverted index")))是我们在 <<inverted-index>> 章节中介绍过的 _倒排索引_ 。这个倒排索引包含一个排序后包含唯一值或词的列表，这些词出现在任何文档中，对于每个词，有一个包含它的文档
列表。


     词  | 文档 1 | 文档 2 | 文档 3 | ...
     ------------------------------------
     brown |   X   |       |  X    | ...
     fox   |   X   |   X   |  X    | ...
     quick |   X   |   X   |       | ...
     the   |   X   |       |  X    | ...


[NOTE]
====
当我们讨论倒排索引时， 我们讨论索引 _文档_。因为历史原因，我们过去用倒排索引索引非结构化的
文本文档。一个 _文档_ 在 Elasticsearch 中是一个 有键值对的 JSON 文档。事实上，在JSON文档中，
每个索引字段都有它自己的倒排索引。
====

这个倒排索引会包含比包含特定词汇的文档列表更多的信息。它会存储一个文档包含每个词的数量，
每个词出现在特定文档中的次数，每个文档中词的排序，每个文档的长度，等等。这些统计结果允许
Elasticsearch 决定哪些词比其它词更重要，哪些文档比其它文档更重要，在<<relevance-intro>>
中有描述。

需要意识到到是 倒排索引为了目的功能的执行需要知道集合中的 _all_ 文档。
很久以前的全文检索，一个大的索引为整个文档集合被构建出来，并写到了硬盘上。一旦新的索引准备好，
他就会替换旧的索引，而且最近的改变就可以搜索了。

[role="pagebreak-before"]
==== 不变的

写到磁盘的倒排索引是 _不可改变_ 的: 它永远不会变化。((("inverted index", "immutability")))
这些不变性有重要的好处：

* 不需要锁。如果你永远不更新index，你不需要担心多进程同时改变数据。
* 一旦索引被读入了内核的文件系统缓存，它留在哪里，因为它不会改变。如果文件系统缓存中没有足够的
  空间，更多的读取会发生在内存中，而不是发生在硬盘读取。这提供了很大的性能提升。
* 其它缓存(像filter缓存)， 停留在索引的生存周期。他们不需要每次数据改变时重新构建，因为数据不会
  变化。

* 写入单个大的倒排索引允许数据被压缩，减少磁盘 I/O 和 需要被缓存到内存的索引的使用量。

当然，一个不变的索引也有不好的地方。主要事实是它是不可变的! 你不能修改它。如果你需要让一个新的文档
可搜索，你需要重新构建整个索引。这放置了一个对一个索引所能包含的数据量和一个索引可以被更新的频率的显著的限制。
