[[making-text-searchable]]
=== 使文本可被搜索

第一个需要被解决的挑战是怎么样((("text", "making it searchable")))让文本可以被搜索。

传统的数据库使用一个字段存储单个值，但是这对全文检索并不够。文本中的每一个单词需要被搜索，这意味着数据库需要有索引单字段多值(这里值指单词)的能力。

很好的支持 _一个字段多个值_ 需求的数据结构((("inverted index")))是我们在 <<inverted-index>> 章节中介绍过的 _倒排索引_ 。这个倒排索引包含一个有序列表，列表中是出现在所有文档的唯一值，或 词项 ，对于每一个词项，有其出现过的所有文档的列表。


     词  | 文档 1 | 文档 2 | 文档 3 | ...
     ------------------------------------
     brown |   X   |       |  X    | ...
     fox   |   X   |   X   |  X    | ...
     quick |   X   |   X   |       | ...
     the   |   X   |       |  X    | ...


[NOTE]
====
当我们讨论倒排索引时， 我们讨论索引 _文档_。因为历史原因，我们过去用倒排索引索引非结构化的
文本文档。一个 _文档_ 在 Elasticsearch 中是一个 有键值对的 JSON 文档。事实上，在JSON文档中，
每个被索引的字段都有它自己的倒排索引。
====

这个倒排索引相比特定词项出现过的文档列表，会包含更多其它信息。它会保存每一个词项出现过的文档总数，
在对应的文档中一个具体词项出现的总次数，词项在文档中的顺序，所有文档的平均长度，等等。这些统计结果允许
Elasticsearch 决定哪些词比其它词更重要，哪些文档比其它文档更重要，在<<relevance-intro>>
中有描述。

需要意识到到是，倒排索引为了能够实现预期功能，需要知道集合中的 _all_ 文档。
很久以前的全文检索，一个大的索引为整个文档集合被构建出来，并写到了硬盘上。一旦新的索引准备好，
他就会替换旧的索引，而且最近的改变就可以搜索了。

[role="pagebreak-before"]
==== 不变性

写到磁盘的倒排索引是 _不可改变_ 的: 它永远不会变化。((("inverted index", "immutability")))
这些不变性有重要的好处：

* 不需要锁。如果你永远不更新index，你不需要担心多进程同时改变数据。
* 一旦索引被读入内核的文件系统缓存， 便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。
* 其它缓存(像filter缓存)，在索引的生命周期内始终有效。它们不需要每次数据改变时重建，因为数据不会
  变化。

* 写入单个大的倒排索引允许数据被压缩，减少磁盘 I/O 和 需要被缓存到内存的索引的使用量。

当然，一个不变的索引也有不好的地方。主要事实是它是不可变的! 你不能修改它。如果你需要让一个新的文档
可被搜索，你需要重建整个索引。这对一个索引所能包含的数据量和索引可被更新的频率造成了很大的限制。
